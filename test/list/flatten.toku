local flatten = import("list").flatten;

local n;
local a = ["420", "69", "1337"];
local x, y, z, g = flatten(a);
assert(x == "420");
assert(y == "69");
assert(z == "1337");
assert(g == nil);
local b = [flatten(a)];
assert(b[0] == "420");
assert(b[1] == "69");
assert(b[2] == "1337");
assert(b[3] == nil);
b[3] = true;
x, y, z, g = flatten(b);
assert(x == "420");
assert(y == "69");
assert(z == "1337");
assert(g == true);

/* use ranges */
x, y, z, g = flatten(b, 0, 1);
assert(x == "420");
assert(y == "69");
assert(z == nil);
assert(g == nil);
x, y, z, g = flatten(b, 1, 2);
assert(x == "69");
assert(y == "1337");
assert(z == nil);
assert(g == nil);
x, y, z, g = flatten(b, 1, 1);
assert(x == "69");
assert(y == nil);
assert(z == nil);
assert(g == nil);
x, y, z, g = flatten(b, 2);
assert(x == "1337");
assert(y == true);
assert(z == nil);
assert(g == nil);

/* empty ranges */
x, y, z, g = flatten(b, 1, 0);
assert(x == nil);
assert(y == nil);
assert(z == nil);
assert(g == nil);
x, y, z, g = flatten(b, 3, 2);
assert(x == nil);
assert(y == nil);
assert(z == nil);
assert(g == nil);
x, y, z, g = flatten(b, 4);
assert(x == nil);
assert(y == nil);
assert(z == nil);
assert(g == nil);


local fn checkerror(msg, f, ...) {
    local s, err = pcall(f, ...);
    assert(!s and string.find(err, msg));
}


a = [];
local lim = 2000;
for (local i=0; i <= lim; i=i+1) a[i]=i;
assert(getargs(lim, flatten(a)) == lim and getargs("last", flatten(a)) == lim);
x = flatten(a);
assert(x == 0);
x = [flatten(a)];
assert(x.len == lim+1 and x[0] == 0 and x[lim] == lim);
x = [flatten(a, lim-2)];
assert(x.len == 3 and x[0] == lim-2 and x[2] == lim);
x = [flatten(a, 9, 5)];
assert(x.last == nil); /// no elements
x = [flatten(a, 11, 10)];
assert(x.len == 0); /// no elements
x,y = flatten(a, 10, 10);
assert(x == 10 and y == nil);
x,y,z = flatten(a, 10, 11);
assert(x == 10 and y == 11 and z == nil);
a,x = flatten([1]);
assert(a==1 and x==nil);
a,x = flatten([1,2], 0, 0);
assert(a==1 and x==nil);

local maxi = (1 << 31) - 1; /// maximum value for an int (usually)
checkerror("end index out of bounds", flatten, [], 2, maxi);
checkerror("start index out of bounds", flatten, [], -1, 5);
if (__heavy) { /// test flatten on big list
    local bl = [];
    local lim = 1<<24; /// bytecode limit
    for (local i = 0; i <= lim; i=i+1)
        bl[i] = i;
    checkerror("too many results", flatten, bl);
}
flatten([], 5, 0);
flatten([], 2, 1);
flatten([], 5, 4);
pcall(flatten, [], 0, maxi + 1);
